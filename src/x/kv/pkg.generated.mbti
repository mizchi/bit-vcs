// Generated using `moon info`, DON'T EDIT IT
package "mizchi/bit/x/kv"

import {
  "mizchi/bit/lib",
  "mizchi/bit/object",
}

// Values

// Errors

// Types and methods
pub(all) struct GitObject {
  id : @object.ObjectId
  obj_type : @object.ObjectType
  data : Bytes
}

pub(all) enum GossipMessage {
  Announce(GossipState)
  WantObjects(Array[@object.ObjectId])
  HaveObjects(Array[GitObject])
  SyncRequest(NodeId, @object.ObjectId)
  SyncResponse(Array[GitObject], @object.ObjectId)
}

pub(all) struct GossipState {
  node_id : NodeId
  head : @object.ObjectId
  clock : VectorClock
  timestamp : Int64
}

pub struct Kv {
  node_id : NodeId
  tree : &@lib.WorkingTree
  store : &@lib.ObjectStore
  mut clock : VectorClock
  mut head : @object.ObjectId
  sync_engine : SyncEngine
  pending_objects : Map[String, GitObject]
  snapshot_cache : Map[Int, SerializedSnapshot]
  snapshot_bytes_cache : Map[Int, Bytes]
}
pub fn Kv::add_peer(Self, PeerInfo) -> Unit
pub fn Kv::apply_pending_objects(Self) -> Int raise @object.GitError
pub fn Kv::clock(Self) -> VectorClock
pub fn Kv::commit(Self, String, Int64) -> @object.ObjectId raise @object.GitError
pub fn Kv::delete(Self, String) -> Unit
pub fn Kv::get(Self, String) -> Bytes?
pub fn Kv::get_gossip_state(Self, Int64) -> GossipState
pub fn Kv::get_peer_cursor(Self, NodeId) -> Int64?
pub fn Kv::get_peers(Self) -> Array[PeerInfo]
pub fn Kv::handle_gossip(Self, GossipMessage, Int64) -> GossipMessage?
pub fn Kv::has(Self, String) -> Bool
pub fn Kv::has_pending_objects(Self) -> Bool
pub fn Kv::head(Self) -> @object.ObjectId
pub fn Kv::is_dirty(Self) -> Bool
pub fn Kv::list(Self, String) -> Array[String]
pub fn Kv::list_recursive(Self, String) -> Array[String]
pub fn Kv::merge(Self, @object.ObjectId, VectorClock, MergeStrategy, Int64) -> MergeResult raise @object.GitError
pub fn Kv::new(NodeId, &@lib.WorkingTree, &@lib.ObjectStore, @object.ObjectId) -> Self
pub fn Kv::node_id(Self) -> NodeId
pub fn Kv::pending_object_count(Self) -> Int
pub fn Kv::record_peer_sync_result(Self, NodeId, Bool, Int64) -> Unit
pub fn Kv::remove_peer(Self, NodeId) -> Bool
pub fn Kv::rollback(Self) -> Unit
pub fn Kv::select_gossip_peers(Self, Int, Int64, timestamp? : Int64) -> Array[PeerInfo]
pub fn Kv::serialize_snapshot(Self, mode? : SnapshotMode) -> SerializedSnapshot
pub fn Kv::serialize_snapshot_bytes(Self, mode? : SnapshotMode) -> Bytes
pub fn Kv::set(Self, String, Bytes) -> Unit
pub fn Kv::set_peer_cursor(Self, NodeId, Int64) -> Unit
pub fn Kv::set_string(Self, String, String) -> Unit
pub fn Kv::sync_round(Self, Int, Int64, Int64, (PeerInfo, GossipMessage) -> Result[GossipMessage?, String]) -> SyncRoundResult

pub(all) struct KvConfig {
  node_id : NodeId
  max_peers : Int
  gossip_interval_ms : Int
  sync_batch_size : Int
}
pub fn KvConfig::default(NodeId) -> Self

pub(all) enum MergeResult {
  NoOp
  FastForward(@object.ObjectId)
  Merged(@object.ObjectId, Array[String])
  Conflict(Array[String])
}

pub(all) enum MergeStrategy {
  LastWriteWins
  KeepBoth
  Custom((Bytes, Bytes) -> Bytes)
}

pub(all) struct NodeId {
  id : String
}
pub fn NodeId::new(String) -> Self
pub impl Eq for NodeId
pub impl Hash for NodeId
pub impl Show for NodeId

pub(all) struct PeerInfo {
  node_id : NodeId
  last_seen : Int64
  head : @object.ObjectId
  endpoint : String
}

pub(all) struct PeerSyncState {
  peer : PeerInfo
  cursor : Int64?
  last_sync_at : Int64?
  last_attempt_at : Int64?
  retry_count : Int
  next_retry_at : Int64
}

pub(all) struct SerializationStats {
  total_bytes : Int
  object_count : Int
  commit_count : Int
  tree_count : Int
  blob_count : Int
  blob_bytes : Int
}

pub(all) struct SerializedObject {
  id : Bytes
  obj_type : Int
  data : Bytes
}

pub(all) struct SerializedSnapshot {
  version : Int
  node_id : String
  head : Bytes
  clock : Array[(String, Int64)]
  objects : Array[SerializedObject]
}
pub fn SerializedSnapshot::byte_size(Self) -> Int
pub fn SerializedSnapshot::from_bytes(Bytes) -> Self
pub fn SerializedSnapshot::stats(Self) -> SerializationStats
pub fn SerializedSnapshot::to_bytes(Self) -> Bytes

pub(all) enum SnapshotMode {
  FullHistory
  HeadState
  TreeAndBlobOnly
}

pub(all) struct SyncEngine {
  config : SyncEngineConfig
  peers : Map[String, PeerSyncState]
}
pub fn SyncEngine::get_cursor(Self, NodeId) -> Int64?
pub fn SyncEngine::get_peers(Self) -> Array[PeerInfo]
pub fn SyncEngine::new(config? : SyncEngineConfig) -> Self
pub fn SyncEngine::record_sync_result(Self, NodeId, Bool, Int64) -> Unit
pub fn SyncEngine::remove_peer(Self, NodeId) -> Bool
pub fn SyncEngine::select_peers(Self, Int, Int64, Int64) -> Array[PeerInfo]
pub fn SyncEngine::set_cursor(Self, NodeId, Int64) -> Unit
pub fn SyncEngine::upsert_peer(Self, PeerInfo) -> Unit

pub(all) struct SyncEngineConfig {
  anti_entropy_interval_ms : Int64
  retry_base_ms : Int64
  retry_max_ms : Int64
}
pub fn SyncEngineConfig::default() -> Self

pub(all) struct SyncResult {
  objects_sent : Int
  objects_received : Int
  conflicts : Array[String]
  new_head : @object.ObjectId
}

pub(all) struct SyncRoundResult {
  selected : Int
  attempted : Int
  succeeded : Int
  failed : Int
  messages_sent : Int
  messages_received : Int
}

pub(all) struct VectorClock {
  clocks : Map[String, Int64]
}
pub fn VectorClock::compare(Self, Self) -> Int
pub fn VectorClock::increment(Self, NodeId) -> Self
pub fn VectorClock::merge(Self, Self) -> Self
pub fn VectorClock::new() -> Self

// Type aliases

// Traits

