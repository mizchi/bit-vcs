// Generated using `moon info`, DON'T EDIT IT
package "mizchi/bit/x/collab"

import {
  "mizchi/bit",
  "mizchi/bit/lib",
}

// Values
pub fn collab_notes_ns_name() -> String

pub fn collab_notes_ref_name() -> String

pub fn find_remote_notes_ref(Array[(@bit.ObjectId, String)]) -> (@bit.ObjectId, String)

pub fn find_upload_notes_ref(Array[(@bit.ObjectId, String)]) -> (@bit.ObjectId, String)?

pub fn issue_comment_key(String, String) -> String

pub fn issue_comment_prefix(String) -> String

pub fn issue_meta_key(String) -> String

pub fn merge_notes_commits(Collab, &@bit.FileSystem, String, &@lib.ObjectStore, &@lib.RefStore, @bit.ObjectId, @bit.ObjectId) -> PrSyncResult raise @bit.GitError

pub fn merge_record_bytes(Bytes, Bytes) -> Bytes

pub fn parse_collab_record(String) -> CollabRecord

pub fn parse_issue(String) -> Issue raise PrError

pub fn parse_issue_comment(String) -> IssueComment raise PrError

pub fn parse_note(String) -> Note

pub fn parse_note_plain(@bit.ObjectId, String) -> Note

pub fn parse_pr_comment(String) -> PrComment raise PrError

pub fn parse_pr_review(String) -> PrReview raise PrError

pub fn parse_pull_request(String) -> PullRequest raise PrError

pub fn pr_comment_key(String, String) -> String

pub fn pr_comment_prefix(String) -> String

pub fn pr_meta_key(String) -> String

pub fn pr_review_key(String, String) -> String

pub fn pr_review_prefix(String) -> String

pub fn short_ref_name(String) -> String

pub fn write_object_bytes(&@bit.FileSystem, String, @bit.ObjectId, Bytes) -> Unit raise @bit.GitError

// Errors
pub(all) suberror PrError {
  NotFound(String)
  InvalidFormat(String)
  InvalidState(String)
  MergeConflict(Array[String])
}
pub impl Eq for PrError
pub impl Show for PrError

// Types and methods
pub struct Collab {
  mut store : CollabStore
}
pub fn Collab::add_comment(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String, String, reply_to? : String?, file_path? : String?, line_number? : Int?, commit_id? : @bit.ObjectId?) -> PrComment raise @bit.GitError
pub fn Collab::add_issue_comment(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String, String, reply_to? : String?) -> IssueComment raise @bit.GitError
pub fn Collab::add_note(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, @bit.ObjectId, String, String, Int64, ns? : String) -> Note raise @bit.GitError
pub fn Collab::add_note_plain(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, @bit.ObjectId, String, ns? : String) -> Unit raise @bit.GitError
pub fn Collab::can_merge(Self, &@lib.ObjectStore, &@lib.RefStore, String) -> Bool raise @bit.GitError
pub fn Collab::close_issue(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String) -> Unit raise @bit.GitError
pub fn Collab::close_pr(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String) -> Unit raise @bit.GitError
pub fn Collab::create_issue(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String, String, labels? : Array[String], assignees? : Array[String]) -> Issue raise @bit.GitError
pub fn Collab::create_pr(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String, String, String, String, source_repo? : String?, source_ref? : String?) -> PullRequest raise @bit.GitError
pub fn Collab::get_issue(Self, &@lib.ObjectStore, String) -> Issue?
pub fn Collab::get_note(Self, &@lib.ObjectStore, &@lib.RefStore, @bit.ObjectId, ns? : String) -> Note? raise @bit.GitError
pub fn Collab::get_pr(Self, &@lib.ObjectStore, String) -> PullRequest?
pub fn Collab::import_issues(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, Array[Issue]) -> ImportStats raise @bit.GitError
pub fn Collab::import_prs(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, Array[PullRequest]) -> ImportStats raise @bit.GitError
pub fn Collab::init(&@lib.ObjectStore, &@lib.RefStore, node_id? : String, signing_key? : String?, require_signed? : Bool) -> Self raise @bit.GitError
pub fn Collab::is_approved(Self, &@lib.ObjectStore, String) -> Bool
pub fn Collab::link_pr_to_issue(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String) -> Unit raise @bit.GitError
pub fn Collab::list_comments(Self, &@lib.ObjectStore, String) -> Array[PrComment]
pub fn Collab::list_issue_comments(Self, &@lib.ObjectStore, String) -> Array[IssueComment]
pub fn Collab::list_issues(Self, &@lib.ObjectStore, state? : IssueState?) -> Array[Issue]
pub fn Collab::list_notes(Self, &@lib.ObjectStore, &@lib.RefStore, ns? : String) -> Array[Note] raise @bit.GitError
pub fn Collab::list_prs(Self, &@lib.ObjectStore, state? : PrState?) -> Array[PullRequest]
pub fn Collab::list_reviews(Self, &@lib.ObjectStore, String) -> Array[PrReview]
pub fn Collab::load(&@lib.ObjectStore, &@lib.RefStore, node_id? : String, signing_key? : String?, require_signed? : Bool) -> Self raise @bit.GitError
pub fn Collab::merge_pr(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String, strategy? : PrMergeStrategy) -> PrMergeResult raise @bit.GitError
pub fn Collab::reload_store(Self, &@lib.ObjectStore, &@lib.RefStore) -> Unit raise @bit.GitError
pub fn Collab::remove_note(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, @bit.ObjectId, ns? : String) -> Unit raise @bit.GitError
pub fn Collab::submit_review(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String, ReviewVerdict, String, @bit.ObjectId) -> PrReview raise @bit.GitError
pub fn Collab::update_issue(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, title? : String?, body? : String?, labels? : Array[String]?, assignees? : Array[String]?) -> Issue raise @bit.GitError
pub fn Collab::update_pr(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, title? : String?, body? : String?, labels? : Array[String]?) -> PullRequest raise @bit.GitError

pub struct CollabRecord {
  version : Int
  key : String
  kind : String
  clock : Map[String, Int64]
  timestamp : Int64
  node : String
  deleted : Bool
  signature : String?
  payload : String
}
pub fn CollabRecord::new(String, String, String, String, Int64, clock? : Map[String, Int64], deleted? : Bool, version? : Int, signature? : String?) -> Self
pub fn CollabRecord::serialize(Self) -> String

pub struct CollabStore {
  node_id : String
  signing_key : String?
  require_signed : Bool
  entries : Map[String, @bit.ObjectId]
  mut head : @bit.ObjectId?
}
pub fn CollabStore::delete_record(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String, String) -> CollabRecord raise @bit.GitError
pub fn CollabStore::get_record(Self, &@lib.ObjectStore, String) -> CollabRecord?
pub fn CollabStore::list_records(Self, &@lib.ObjectStore, String, include_deleted? : Bool) -> Array[CollabRecord]
pub fn CollabStore::load(&@lib.ObjectStore, &@lib.RefStore, node_id? : String, signing_key? : String?, require_signed? : Bool) -> Self raise @bit.GitError
pub fn CollabStore::node_id(Self) -> String
pub fn CollabStore::put_record(Self, &@lib.ObjectStore, &@lib.RefStore, &@lib.Clock, String, String, String, String) -> CollabRecord raise @bit.GitError
pub fn CollabStore::require_signed(Self) -> Bool
pub fn CollabStore::signing_key(Self) -> String?

pub struct ImportStats {
  created : Int
  updated : Int
}
pub fn ImportStats::created(Self) -> Int
pub fn ImportStats::new(Int, Int) -> Self
pub fn ImportStats::updated(Self) -> Int

pub struct Issue {
  id : String
  title : String
  body : String
  author : String
  created_at : Int64
  updated_at : Int64
  state : IssueState
  labels : Array[String]
  assignees : Array[String]
  linked_prs : Array[String]
}
pub fn Issue::assignees(Self) -> Array[String]
pub fn Issue::author(Self) -> String
pub fn Issue::body(Self) -> String
pub fn Issue::created_at(Self) -> Int64
pub fn Issue::id(Self) -> String
pub fn Issue::labels(Self) -> Array[String]
pub fn Issue::linked_prs(Self) -> Array[String]
pub fn Issue::new(String, String, String, String, Int64, Int64, IssueState, labels? : Array[String], assignees? : Array[String], linked_prs? : Array[String]) -> Self
pub fn Issue::serialize(Self) -> String
pub fn Issue::state(Self) -> IssueState
pub fn Issue::title(Self) -> String
pub fn Issue::updated_at(Self) -> Int64

pub struct IssueComment {
  id : String
  issue_id : String
  author : String
  body : String
  created_at : Int64
  reply_to : String?
}
pub fn IssueComment::author(Self) -> String
pub fn IssueComment::body(Self) -> String
pub fn IssueComment::created_at(Self) -> Int64
pub fn IssueComment::id(Self) -> String
pub fn IssueComment::issue_id(Self) -> String
pub fn IssueComment::new(String, String, String, String, Int64, reply_to? : String?) -> Self
pub fn IssueComment::reply_to(Self) -> String?
pub fn IssueComment::serialize(Self) -> String

pub(all) enum IssueState {
  Open
  Closed
}
pub fn IssueState::to_string(Self) -> String
pub impl Eq for IssueState
pub impl Show for IssueState

pub struct Note {
  commit_id : @bit.ObjectId
  body : String
  author : String
  created_at : Int64
  ns : String
}
pub fn Note::author(Self) -> String
pub fn Note::body(Self) -> String
pub fn Note::commit_id(Self) -> @bit.ObjectId
pub fn Note::created_at(Self) -> Int64
pub fn Note::new(@bit.ObjectId, String, String, Int64, ns? : String) -> Self
pub fn Note::ns(Self) -> String
pub fn Note::serialize(Self) -> String
pub fn Note::serialize_plain(Self) -> String

pub struct PrComment {
  id : String
  pr_id : String
  author : String
  body : String
  created_at : Int64
  reply_to : String?
  file_path : String?
  line_number : Int?
  commit_id : @bit.ObjectId?
}
pub fn PrComment::author(Self) -> String
pub fn PrComment::body(Self) -> String
pub fn PrComment::commit_id(Self) -> @bit.ObjectId?
pub fn PrComment::created_at(Self) -> Int64
pub fn PrComment::file_path(Self) -> String?
pub fn PrComment::id(Self) -> String
pub fn PrComment::line_number(Self) -> Int?
pub fn PrComment::new(String, String, String, String, Int64, reply_to? : String?, file_path? : String?, line_number? : Int?, commit_id? : @bit.ObjectId?) -> Self
pub fn PrComment::pr_id(Self) -> String
pub fn PrComment::reply_to(Self) -> String?
pub fn PrComment::serialize(Self) -> String

pub struct PrMergeResult {
  success : Bool
  commit_id : @bit.ObjectId?
  conflicts : Array[String]
  message : String
}
pub fn PrMergeResult::commit_id(Self) -> @bit.ObjectId?
pub fn PrMergeResult::conflicts(Self) -> Array[String]
pub fn PrMergeResult::message(Self) -> String
pub fn PrMergeResult::success(Self) -> Bool

pub(all) enum PrMergeStrategy {
  Merge
  Squash
  FastForward
}

pub struct PrReview {
  id : String
  pr_id : String
  author : String
  verdict : ReviewVerdict
  body : String
  created_at : Int64
  commit_id : @bit.ObjectId
}
pub fn PrReview::author(Self) -> String
pub fn PrReview::body(Self) -> String
pub fn PrReview::commit_id(Self) -> @bit.ObjectId
pub fn PrReview::created_at(Self) -> Int64
pub fn PrReview::id(Self) -> String
pub fn PrReview::new(String, String, String, ReviewVerdict, String, Int64, @bit.ObjectId) -> Self
pub fn PrReview::pr_id(Self) -> String
pub fn PrReview::serialize(Self) -> String
pub fn PrReview::verdict(Self) -> ReviewVerdict

pub(all) enum PrState {
  Open
  Merged
  Closed
}
pub fn PrState::to_string(Self) -> String
pub impl Eq for PrState
pub impl Show for PrState

pub struct PrSyncResult {
  success : Bool
  message : String
  local_commit : @bit.ObjectId?
  remote_commit : @bit.ObjectId?
}
pub fn PrSyncResult::local_commit(Self) -> @bit.ObjectId?
pub fn PrSyncResult::message(Self) -> String
pub fn PrSyncResult::new(Bool, String, @bit.ObjectId?, @bit.ObjectId?) -> Self
pub fn PrSyncResult::remote_commit(Self) -> @bit.ObjectId?
pub fn PrSyncResult::success(Self) -> Bool

pub struct PullRequest {
  id : String
  title : String
  body : String
  source_branch : String
  source_repo : String?
  source_ref : String?
  source_commit : @bit.ObjectId
  target_branch : String
  target_commit : @bit.ObjectId
  author : String
  created_at : Int64
  updated_at : Int64
  state : PrState
  labels : Array[String]
  closes_issues : Array[String]
  merge_commit : @bit.ObjectId?
}
pub fn PullRequest::author(Self) -> String
pub fn PullRequest::body(Self) -> String
pub fn PullRequest::closes_issues(Self) -> Array[String]
pub fn PullRequest::created_at(Self) -> Int64
pub fn PullRequest::id(Self) -> String
pub fn PullRequest::labels(Self) -> Array[String]
pub fn PullRequest::merge_commit(Self) -> @bit.ObjectId?
pub fn PullRequest::new(String, String, String, String, @bit.ObjectId, String, @bit.ObjectId, String, Int64, Int64, PrState, Array[String], closes_issues? : Array[String], merge_commit? : @bit.ObjectId?, source_repo? : String?, source_ref? : String?) -> Self
pub fn PullRequest::serialize(Self) -> String
pub fn PullRequest::source_branch(Self) -> String
pub fn PullRequest::source_commit(Self) -> @bit.ObjectId
pub fn PullRequest::source_ref(Self) -> String?
pub fn PullRequest::source_repo(Self) -> String?
pub fn PullRequest::state(Self) -> PrState
pub fn PullRequest::target_branch(Self) -> String
pub fn PullRequest::target_commit(Self) -> @bit.ObjectId
pub fn PullRequest::title(Self) -> String
pub fn PullRequest::updated_at(Self) -> Int64

pub(all) enum ReviewVerdict {
  Approved
  RequestChanges
  Comment
}
pub fn ReviewVerdict::to_string(Self) -> String
pub impl Eq for ReviewVerdict
pub impl Show for ReviewVerdict

// Type aliases

// Traits

