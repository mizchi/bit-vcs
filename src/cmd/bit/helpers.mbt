///| Helper functions and utilities for git-shim

///|
fn io_error(err : @fs.IOError) -> @bitcore.GitError {
  @bitcore.GitError::IoError(err.to_string())
}

///|
fn bytes_from_array(arr : Array[Byte]) -> Bytes {
  Bytes::from_array(FixedArray::makei(arr.length(), i => arr[i]))
}

///|
fn str_to_bytes(s : String) -> Bytes {
  let arr : Array[Byte] = []
  for c in s {
    arr.push(c.to_int().to_byte())
  }
  bytes_from_array(arr)
}

///|
async fn warn_unimplemented_arg(cmd : String, arg : String) -> Unit {
  if arg == "--" {
    return
  }
  let msg = "warning: " + cmd + ": unsupported option '" + arg + "'\n"
  @stdio.stderr.write(str_to_bytes(msg))
}

///|
async fn print_line(s : String) -> Unit {
  @stdio.stdout.write(str_to_bytes(s + "\n"))
}

///|
async fn print_str(s : String) -> Unit {
  @stdio.stdout.write(str_to_bytes(s))
}

///|
async fn eprint_line(s : String) -> Unit {
  @stdio.stderr.write(str_to_bytes(s + "\n"))
}

///|
struct RunGitCommandInvocation {
  cwd : String?
  git_dir : String?
  cmd : String
  rest : Array[String]
}

///|
struct RunGitEnvSnapshot {
  shim_cwd : String?
  git_dir : String?
  bit_work_tree : String?
}

///|
fn resolve_run_git_path(path : String, cwd : String?) -> String {
  if path.has_prefix("/") {
    return path
  }
  match cwd {
    Some(base) => normalize_path(base + "/" + path)
    None =>
      @sys.get_env_var("GIT_SHIM_PWD")
      .map(base => normalize_path(base + "/" + path))
      .unwrap_or(path)
  }
}

///|
fn parse_run_git_invocation(
  args : Array[String],
  cwd : String?,
) -> RunGitCommandInvocation? {
  let mut i = 0
  let mut resolved_cwd = cwd
  let mut resolved_git_dir : String? = None
  while i < args.length() {
    let arg = args[i]
    if arg == "-C" && i + 1 < args.length() {
      resolved_cwd = Some(resolve_run_git_path(args[i + 1], resolved_cwd))
      i += 2
      continue
    }
    if arg == "--git-dir" && i + 1 < args.length() {
      resolved_git_dir = Some(resolve_run_git_path(args[i + 1], resolved_cwd))
      i += 2
      continue
    }
    if arg.has_prefix("--git-dir=") {
      let raw = String::unsafe_substring(arg, start=10, end=arg.length())
      resolved_git_dir = Some(resolve_run_git_path(raw, resolved_cwd))
      i += 1
      continue
    }
    if arg == "-c" && i + 1 < args.length() {
      i += 2
      continue
    }
    if arg == "--version" || arg == "-v" {
      return Some({
        cwd: resolved_cwd,
        git_dir: resolved_git_dir,
        cmd: "version",
        rest: collect_args(args, i + 1),
      })
    }
    if arg.has_prefix("-") {
      i += 1
      continue
    }
    return Some({
      cwd: resolved_cwd,
      git_dir: resolved_git_dir,
      cmd: arg,
      rest: collect_args(args, i + 1),
    })
  }
  None
}

///|
fn restore_env_var(name : String, value : String?) -> Unit {
  match value {
    Some(v) => @sys.set_env_var(name, v)
    None => @sys.unset_env_var(name)
  }
}

///|
fn enter_run_git_env(cwd : String?, git_dir : String?) -> RunGitEnvSnapshot {
  let snapshot = {
    shim_cwd: @sys.get_env_var("GIT_SHIM_CWD"),
    git_dir: @sys.get_env_var("GIT_DIR"),
    bit_work_tree: @sys.get_env_var("GIT_WORK_TREE"),
  }
  let fs = OsFs::new()
  match git_dir {
    Some(dir) => @sys.set_env_var("GIT_DIR", dir)
    None => ()
  }
  match cwd {
    Some(dir) => {
      @sys.set_env_var("GIT_SHIM_CWD", dir)
      if @sys.get_env_var("GIT_DIR") is None {
        @sys.set_env_var("GIT_DIR", default_repo_marker_path(fs, dir))
      }
      if @sys.get_env_var("GIT_WORK_TREE") is None {
        @sys.set_env_var("GIT_WORK_TREE", dir)
      }
    }
    None => ()
  }
  snapshot
}

///|
fn restore_run_git_env(snapshot : RunGitEnvSnapshot) -> Unit {
  restore_env_var("GIT_SHIM_CWD", snapshot.shim_cwd)
  restore_env_var("GIT_DIR", snapshot.git_dir)
  restore_env_var("GIT_WORK_TREE", snapshot.bit_work_tree)
}

///|
async fn run_git_internal_command(
  cmd : String,
  rest : Array[String],
) -> Int raise Error {
  match cmd {
    "version" => {
      print_line("git version 2.47.0 (bit)")
      0
    }
    "clone" => {
      handle_clone(rest)
      0
    }
    "pull" => {
      handle_pull(rest)
      0
    }
    "fetch" => {
      handle_fetch(rest)
      0
    }
    "sparse-checkout" => {
      handle_sparse_checkout(rest)
      0
    }
    "checkout" => {
      handle_checkout(rest)
      0
    }
    "reset" => {
      handle_reset(rest)
      0
    }
    "config" => {
      handle_config(rest)
      0
    }
    "maintenance" => {
      handle_maintenance(rest)
      0
    }
    "fsmonitor--daemon" => 0
    _ => {
      eprint_line("fatal: unsupported internal git command '\{cmd}'")
      1
    }
  }
}

///|
async fn run_git_command(
  args : Array[String],
  cwd~ : String?,
  inherit_env? : Bool = true,
) -> Int {
  ignore(inherit_env)
  guard parse_run_git_invocation(args, cwd) is Some(invocation) else {
    eprint_line("fatal: missing subcommand")
    return 1
  }
  let snapshot = enter_run_git_env(invocation.cwd, invocation.git_dir)
  let code = run_git_internal_command(invocation.cmd, invocation.rest) catch {
    err => {
      if @async.is_being_cancelled() || @async.is_cancellation_error(err) {
        restore_run_git_env(snapshot)
        raise err
      }
      eprint_line("\{invocation.cmd} failed: \{err}")
      1
    }
  }
  restore_run_git_env(snapshot)
  code
}

///|
fn decode_bytes(data : Bytes) -> String {
  @encoding.decoder(@encoding.Encoding::UTF8).decode_lossy(data[:])
}

///|
fn trim_string(s : String) -> String {
  let mut start = 0
  let mut end = s.length()
  while start < end {
    let c = s.unsafe_get(start)
    if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
      start += 1
    } else {
      break
    }
  }
  while end > start {
    let c = s.unsafe_get(end - 1)
    if c == ' ' || c == '\t' || c == '\n' || c == '\r' {
      end -= 1
    } else {
      break
    }
  }
  if start == 0 && end == s.length() {
    s
  } else {
    String::unsafe_substring(s, start~, end~)
  }
}

///|
fn is_hex_char(c : Char) -> Bool {
  (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')
}

///|
fn is_hex_string(s : String) -> Bool {
  if s.length() == 0 {
    return false
  }
  for c in s {
    if (c |> is_hex_char |> not) {
      return false
    }
  }
  true
}

///|
fn parent_dir(path : String) -> String {
  if path.length() == 0 || path == "/" {
    return "/"
  }
  let sep = @path.sep.to_string()
  match path.rev_find(sep) {
    None => ""
    Some(idx) => if idx == 0 { sep } else { (try! path[:idx]).to_string() }
  }
}

///|
fn ensure_dir(path : String) -> Unit raise @bitcore.GitError {
  if path.length() == 0 || path == "/" || path == "." {
    return ()
  }
  if @fs.path_exists(path) {
    let is_dir = @fs.is_dir(path) catch { _ => false }
    if is_dir {
      return ()
    }
    raise @bitcore.GitError::IoError("path exists and is not dir: " + path)
  }
  let parent = parent_dir(path)
  if parent.length() > 0 && parent != path {
    ensure_dir(parent)
  }
  @fs.create_dir(path) catch {
    err => raise io_error(err)
  }
}

///|
fn collect_args(args : Array[String], start : Int) -> Array[String] {
  let out : Array[String] = []
  for i in start..<args.length() {
    out.push(args[i])
  }
  out
}

///|
fn prepend_arg(first : String, rest : Array[String]) -> Array[String] {
  let out : Array[String] = [first]
  out.append(rest)
  out
}

///|
async fn read_all_stdin() -> Bytes {
  let out : Array[Byte] = []
  while true {
    match @stdio.stdin.read_some(max_len=8192) {
      None => break
      Some(bytes) =>
        for b in bytes {
          out.push(b)
        }
    }
  }
  bytes_from_array(out)
}

///|
fn normalize_path(path : String) -> String {
  let parts : Array[String] = []
  for part_view in path.split("/") {
    let part = part_view.to_string()
    if part == "" || part == "." {
      continue
    } else if part == ".." {
      if parts.length() > 0 && parts[parts.length() - 1] != ".." {
        let _ = parts.pop()
      } else if not(path.has_prefix("/")) {
        parts.push(part)
      }
    } else {
      parts.push(part)
    }
  }
  let result = parts.join("/")
  if path.has_prefix("/") {
    if result.length() == 0 {
      "/"
    } else {
      "/" + result
    }
  } else if result.length() == 0 {
    "."
  } else {
    result
  }
}

///|
fn join_repo_marker(root : String, marker : String) -> String {
  if root == "/" {
    "/" + marker
  } else if root == "." {
    marker
  } else {
    root + "/" + marker
  }
}

///|
fn detect_repo_marker_path(
  fs : &@bitcore.RepoFileSystem,
  root : String,
) -> String? {
  let git_path = join_repo_marker(root, ".git")
  if fs.is_dir(git_path) || fs.is_file(git_path) {
    return Some(git_path)
  }
  let bit_path = join_repo_marker(root, ".bit")
  if fs.is_dir(bit_path) || fs.is_file(bit_path) {
    return Some(bit_path)
  }
  None
}

///|
fn default_repo_marker_path(
  fs : &@bitcore.RepoFileSystem,
  root : String,
) -> String {
  match detect_repo_marker_path(fs, root) {
    Some(path) => path
    None => join_repo_marker(root, ".git")
  }
}

///|
fn is_bare_repo_dir(path : String) -> Bool {
  let head_ok = @fs.is_file(path + "/HEAD") catch { _ => false }
  let objs_ok = @fs.is_dir(path + "/objects") catch { _ => false }
  head_ok && objs_ok
}

///|
fn find_repo_root(start : String) -> String? {
  let mut current = normalize_path(start)
  if current.length() == 0 {
    current = "."
  }
  let ceiling_dirs : Array[String] = []
  match @sys.get_env_var("GIT_CEILING_DIRECTORIES") {
    Some(raw) =>
      for view in raw.split(":") {
        let dir = view.to_string()
        if dir.length() == 0 {
          continue
        }
        ceiling_dirs.push(normalize_path(dir))
      }
    None => ()
  }
  let mut last = ""
  while true {
    if ceiling_dirs.length() > 0 {
      for ceiling in ceiling_dirs {
        if current == ceiling {
          return None
        }
      }
    }
    let bit_path = join_repo_marker(current, ".git")
    let is_git_dir = @fs.is_dir(bit_path) catch { _ => false }
    let is_git_file = if is_git_dir {
      false
    } else {
      @fs.is_file(bit_path) catch {
        _ => false
      }
    }
    if is_git_dir || is_git_file {
      return Some(current)
    }
    let bit_path = join_repo_marker(current, ".bit")
    let is_bit_dir = @fs.is_dir(bit_path) catch { _ => false }
    let is_bit_file = if is_bit_dir {
      false
    } else {
      @fs.is_file(bit_path) catch {
        _ => false
      }
    }
    if is_bit_dir || is_bit_file {
      return Some(current)
    }
    let parent = parent_dir(current)
    let next = if parent.length() == 0 { "." } else { parent }
    if next == current || next == last {
      break
    }
    last = current
    current = next
  }
  None
}

///|
fn get_work_root() -> String {
  match @sys.get_env_var("GIT_SHIM_CWD") {
    Some(dir) => dir
    None =>
      match @sys.get_env_var("GIT_WORK_TREE") {
        Some(dir) => dir
        None =>
          match @sys.get_env_var("GIT_DIR") {
            Some(dir) => normalize_repo_root(dir)
            None =>
              match @sys.get_env_var("GIT_SHIM_PWD") {
                Some(pwd) =>
                  if is_bare_repo_dir(pwd) {
                    pwd
                  } else {
                    find_repo_root(pwd).unwrap_or(".")
                  }
                None => {
                  if @env.current_dir() is Some(dir) {
                    if is_bare_repo_dir(dir) {
                      return dir
                    }
                  }
                  if is_bare_repo_dir(".") {
                    return "."
                  }
                  if @sys.get_env_var("PWD") is Some(pwd) {
                    if is_bare_repo_dir(pwd) {
                      return pwd
                    }
                  }
                  "."
                }
              }
          }
      }
  }
}

///|
fn normalize_repo_root(path : String) -> String {
  if path == ".git" || path == ".bit" {
    return "."
  }
  if path.has_suffix("/.git") && path.length() > 5 {
    return (try! path[:path.length() - 5]).to_string()
  }
  if path.has_suffix("/.bit") && path.length() > 5 {
    return (try! path[:path.length() - 5]).to_string()
  }
  path
}

///|
fn resolve_git_dir(fs : &@bitcore.RepoFileSystem, root : String) -> String {
  let default_git_dir = default_repo_marker_path(fs, root)
  match @sys.get_env_var("GIT_DIR") {
    Some(dir) => {
      let resolved = if dir.has_prefix("/") {
        dir
      } else {
        match @sys.get_env_var("GIT_SHIM_CWD") {
          Some(base) => normalize_path(base + "/" + dir)
          None =>
            @sys.get_env_var("GIT_SHIM_PWD")
            .map(base => normalize_path(base + "/" + dir))
            .unwrap_or(dir)
        }
      }
      if fs.is_file(resolved) {
        @bitlib.resolve_gitdir(fs, resolved)
      } else if fs.is_dir(resolved) {
        resolved
      } else if is_bare_repo_dir(root) {
        root
      } else {
        resolved
      }
    }
    None =>
      if fs.is_file(default_git_dir) {
        @bitlib.resolve_gitdir(fs, default_git_dir)
      } else if fs.is_dir(default_git_dir) {
        default_git_dir
      } else if is_bare_repo_dir(root) {
        root
      } else {
        default_git_dir
      }
  }
}

///|
fn is_reftable_repo(fs : &@bitcore.RepoFileSystem, git_dir : String) -> Bool {
  if fs.is_dir(git_dir + "/reftable") {
    return true
  }
  match
    @bitlib.read_config_value(
      fs,
      git_dir + "/config",
      "extensions",
      "refstorage",
    ) {
    Some(value) => value.to_lower() == "reftable"
    None => false
  }
}

///|
fn repo_object_format(
  fs : &@bitcore.RepoFileSystem,
  git_dir : String,
) -> String {
  match
    @bitlib.read_config_value(
      fs,
      git_dir + "/config",
      "extensions",
      "objectformat",
    ) {
    Some(value) => if value.to_lower() == "sha256" { "sha256" } else { "sha1" }
    None => "sha1"
  }
}

///|
fn repo_compat_object_format(
  fs : &@bitcore.RepoFileSystem,
  git_dir : String,
) -> String? {
  match
    @bitlib.read_config_value(
      fs,
      git_dir + "/config",
      "extensions",
      "compatobjectformat",
    ) {
    Some(value) => {
      let normalized = @bitlib.config_strip_quotes(value).to_lower()
      if normalized == "sha1" || normalized == "sha256" {
        Some(normalized)
      } else {
        None
      }
    }
    None => None
  }
}

///|
fn get_author_string() -> String {
  match @sys.get_env_var("GIT_AUTHOR_NAME") {
    Some(name) => {
      let email = @sys.get_env_var("GIT_AUTHOR_EMAIL").unwrap_or("unknown")
      name + " <" + email + ">"
    }
    None =>
      match @sys.get_env_var("USER") {
        Some(u) => u + " <" + u + "@localhost>"
        None => "Unknown <unknown@localhost>"
      }
  }
}

///|
fn get_committer_string() -> String {
  match @sys.get_env_var("GIT_COMMITTER_NAME") {
    Some(name) => {
      let email = @sys.get_env_var("GIT_COMMITTER_EMAIL").unwrap_or("unknown")
      name + " <" + email + ">"
    }
    None => get_author_string()
  }
}

///|
fn get_hub_signing_key() -> String? {
  match @sys.get_env_var("BIT_COLLAB_SIGN_KEY") {
    Some(value) => if value.length() > 0 { Some(value) } else { None }
    None => None
  }
}

///|
fn get_hub_require_signed() -> Bool {
  match @sys.get_env_var("BIT_COLLAB_REQUIRE_SIGNED") {
    Some(value) => {
      let normalized = value.to_lower()
      normalized == "1" || normalized == "true" || normalized == "yes"
    }
    None => false
  }
}

///|
fn get_commit_timestamp() -> Int64 {
  match @sys.get_env_var("GIT_COMMITTER_DATE") {
    Some(s) =>
      match parse_git_env_timestamp(s) {
        Some(ts) => ts
        None => get_current_timestamp()
      }
    None => get_current_timestamp()
  }
}

///|
fn parse_git_env_timestamp(raw : String) -> Int64? {
  let mut token : String? = None
  for part_view in raw.split(" ") {
    let part = part_view.to_string()
    if part.length() > 0 {
      token = Some(part)
      break
    }
  }
  match token {
    Some(part) =>
      if part.has_prefix("@") {
        let numeric = String::unsafe_substring(part, start=1, end=part.length())
        let parsed = @strconv.parse_int64(numeric) catch { _ => return None }
        Some(parsed)
      } else {
        let parsed = @strconv.parse_int64(part) catch { _ => return None }
        Some(parsed)
      }
    None => None
  }
}

///|
fn get_commit_timezone() -> String {
  match @sys.get_env_var("GIT_COMMITTER_DATE") {
    Some(raw) =>
      match parse_git_env_timezone(raw) {
        Some(tz) => tz
        None => "+0000"
      }
    None => "+0000"
  }
}

///|
fn parse_git_env_timezone(raw : String) -> String? {
  let fields : Array[String] = []
  for part_view in raw.split(" ") {
    let part = part_view.to_string()
    if part.length() > 0 {
      fields.push(part)
    }
  }
  if fields.length() < 2 {
    return None
  }
  let tz = fields[fields.length() - 1]
  if is_valid_timezone_token(tz) {
    Some(tz)
  } else {
    None
  }
}

///|
fn is_valid_timezone_token(token : String) -> Bool {
  if token.length() != 5 {
    return false
  }
  let chars = token.to_array()
  if not(chars[0] == '+' || chars[0] == '-') {
    return false
  }
  for i = 1; i < chars.length(); i = i + 1 {
    let c = chars[i]
    if c < '0' || c > '9' {
      return false
    }
  }
  true
}

///|
async fn run_checkout_with_sensitive_hooks(
  fs : &@bitcore.FileSystem,
  rfs : &@bitcore.RepoFileSystem,
  root : String,
  spec : String,
  detach? : Bool = false,
  update_worktree? : Bool = true,
  update_index? : Bool = true,
) -> @bitcore.ObjectId raise Error {
  hooks_ensure_sensitive_hook_approval(fs, rfs, root, "post-checkout")
  @bitlib.checkout(
    fs,
    rfs,
    root,
    spec,
    detach~,
    update_worktree~,
    update_index~,
  )
}

///|
async fn run_merge_with_sensitive_hooks(
  fs : &@bitcore.FileSystem,
  rfs : &@bitcore.RepoFileSystem,
  root : String,
  target : @bitcore.ObjectId,
  message : String,
  author : String,
  timestamp : Int64,
) -> @bitlib.MergeResult raise Error {
  hooks_ensure_sensitive_hook_approval(fs, rfs, root, "post-merge")
  @bitlib.merge(fs, rfs, root, target, message, author, timestamp)
}
