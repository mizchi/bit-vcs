#!/bin/sh
set -eu

script_path="$0"
case "$script_path" in
  */*) ;;
  *)
    script_path="$(command -v "$0" 2>/dev/null || true)"
    ;;
esac
script_dir="$(cd "$(dirname "$script_path")" && pwd)"

real_git="${GIT_SHIM_REAL_GIT:-${SHIM_REAL_GIT:-}}"
if [ -z "$real_git" ]; then
  real_git_file="$script_dir/../real-git-path"
  if [ -f "$real_git_file" ]; then
    real_git="$(cat "$real_git_file" 2>/dev/null || true)"
  fi
fi
if [ -z "$real_git" ]; then
  echo "GIT_SHIM_REAL_GIT is not set" >&2
  exit 2
fi

case "$real_git" in
  /*) ;;
  *)
    resolved_real_git="$(command -v "$real_git" 2>/dev/null || true)"
    if [ -n "$resolved_real_git" ]; then
      real_git="$resolved_real_git"
    fi
    ;;
esac
if [ "$real_git" = "$script_path" ] || [ "$real_git" = "$script_dir/git" ]; then
  echo "git-shim: real git points to shim; set SHIM_REAL_GIT or tools/git-shim/real-git-path to an absolute path" >&2
  exit 2
fi

log_file="${GIT_SHIM_LOG:-${SHIM_LOG:-$script_dir/../shim.log}}"
log() {
  printf '%s\n' "$*" >> "$log_file"
}

capture_stderr="${GIT_SHIM_CAPTURE:-${SHIM_CAPTURE:-}}"
strict_mode="${GIT_SHIM_STRICT:-${SHIM_STRICT:-}}"
force_pack_intercept="${GIT_SHIM_FORCE_PACK_INTERCEPT:-${SHIM_FORCE_PACK_INTERCEPT:-}}"
force_transport_intercept="${GIT_SHIM_FORCE_TRANSPORT_INTERCEPT:-${SHIM_FORCE_TRANSPORT_INTERCEPT:-}}"
random_mode="${GIT_SHIM_RANDOM_MODE:-${SHIM_RANDOM_MODE:-}}"
random_ratio_raw="${GIT_SHIM_RANDOM_RATIO:-${SHIM_RANDOM_RATIO:-}}"
fallback_real_git="${GIT_SHIM_REAL_GIT_FALLBACK:-${SHIM_REAL_GIT_FALLBACK:-}}"

has_command_support() {
  git_bin="$1"
  subcmd="$2"
  "$git_bin" help "$subcmd" >/dev/null 2>&1
}

resolve_real_git() {
  subcmd="${1:-}"
  shift
  support_cmd="$subcmd"
  if [ "$subcmd" = "help" ]; then
    seen_help=0
    for arg in "$@"; do
      if [ "$seen_help" -eq 1 ]; then
        case "$arg" in
          -*) ;;
          *) support_cmd="$arg"; break ;;
        esac
      fi
      case "$arg" in
        help)
          seen_help=1
          ;;
      esac
    done
  fi
  if [ -z "$subcmd" ] || [ -z "$fallback_real_git" ]; then
    printf '%s\n' "$real_git"
    return 0
  fi
  if has_command_support "$real_git" "$support_cmd"; then
    printf '%s\n' "$real_git"
    return 0
  fi
  if has_command_support "$fallback_real_git" "$support_cmd"; then
    log "fallback $subcmd $*"
    printf '%s\n' "$fallback_real_git"
    return 0
  fi
  printf '%s\n' "$real_git"
}

exec_real_git() {
  git_bin="$1"
  shift
  if [ "$capture_stderr" = "1" ]; then
    "$git_bin" "$@" 2>>"$script_dir/../shim-stderr.log"
  else
    "$git_bin" "$@"
  fi
}

is_uint() {
  case "${1:-}" in
    ''|*[!0-9]*)
      return 1
      ;;
    *)
      return 0
      ;;
  esac
}

# Fast-path global --exec-path (query only; preserve override when subcommand exists)
if [ "${1:-}" = "--exec-path" ] && [ "$#" -gt 1 ]; then
  :
elif case "${1:-}" in --exec-path=*) true ;; *) false ;; esac && [ "$#" -gt 1 ]; then
  :
else
  case "${1:-}" in
    --exec-path)
      exec_path="${GIT_SHIM_EXEC_PATH:-${SHIM_EXEC_PATH:-}}"
      if [ -n "$exec_path" ]; then
        printf '%s\n' "$exec_path"
        exit 0
      fi
      exec "$real_git" --exec-path
      ;;
    --exec-path=*)
      exec_path="${GIT_SHIM_EXEC_PATH:-${SHIM_EXEC_PATH:-}}"
      if [ -n "$exec_path" ]; then
        printf '%s\n' "$exec_path"
        exit 0
      fi
      exec "$real_git" "$@"
      ;;
    --help|-h|-v|--version)
      exec "$real_git" "$@"
      ;;
  esac
fi

# Parse global options to find subcommand (must be done before -c validation)
subcmd=""
take_next=0
skip_next=0
for arg in "$@"; do
  if [ "$skip_next" -eq 1 ]; then
    skip_next=0
    continue
  fi
  if [ "$take_next" -eq 1 ]; then
    subcmd="$arg"
    break
  fi
  case "$arg" in
    --)
      take_next=1
      ;;
    -c|-C|--git-dir|--work-tree|--namespace|--super-prefix|--git-path)
      skip_next=1
      ;;
    --exec-path)
      skip_next=1
      ;;
    --exec-path=*)
      ;;
    -*)
      ;;
    *)
      subcmd="$arg"
      break
      ;;
  esac
done

# Validate -c key=value syntax for global options (before subcommand only)
prev_is_c=0
skip_next_c=0
for arg in "$@"; do
  # Handle -c value argument (don't treat as subcommand)
  if [ "$prev_is_c" -eq 1 ]; then
    prev_is_c=0
    case "$arg" in
      *=*) ;;
      *)
        key_lc=$(printf '%s' "$arg" | tr 'A-Z' 'a-z')
        case "$key_lc" in
          receive.fsck.skiplist|uploadpackfilter.*)
            printf 'unable to parse '\''%s'\'' from command-line config\n' "$key_lc" >&2
            exit 129
            ;;
        esac
        ;;
    esac
    continue
  fi
  # Stop at subcommand
  case "$arg" in
    -c)
      prev_is_c=1
      ;;
    -C|--git-dir|--work-tree|--namespace|--super-prefix|--git-path|--exec-path|--)
      ;;
    --exec-path=*|--git-dir=*|--work-tree=*)
      ;;
    -*)
      ;;
    *)
      # Found subcommand, stop checking
      break
      ;;
  esac
done
if [ "$prev_is_c" -eq 1 ]; then
  printf 'no config key given for -c\n' >&2
  exit 129
fi

if [ -z "$subcmd" ]; then
  log "pass <none> $*"
  real_bin="$(resolve_real_git)"
  set +e
  if [ "$capture_stderr" = "1" ]; then
    exec_real_git "$real_bin" "$@"
  else
    exec_real_git "$real_bin" "$@"
  fi
  status=$?
  set -e
  if [ "$status" -ne 0 ]; then
    log "fail <none> cwd=$(pwd)"
    log "fail <none> env HOME=${HOME-} GIT_DIR=${GIT_DIR-} GIT_WORK_TREE=${GIT_WORK_TREE-} GIT_EXEC_PATH=${GIT_EXEC_PATH-} GIT_TEMPLATE_DIR=${GIT_TEMPLATE_DIR-} PATH=${PATH-}"
    env | sort >> "$log_file"
  fi
  log "exit <none> $status"
  exit $status
fi

if [ "$subcmd" = "version" ]; then
  has_build_opts=0
  for arg in "$@"; do
    if [ "$arg" = "--build-options" ]; then
      has_build_opts=1
      break
    fi
  done
    if [ "$has_build_opts" -eq 1 ]; then
    real_bin="$(resolve_real_git "$subcmd" "$@")"
    set +e
    output=$("$real_bin" "$@" 2>&1)
    status=$?
    set -e
    if [ "$status" -eq 0 ]; then
      printf '%s\n' "$output"
      if ! printf '%s\n' "$output" | grep -q '^default-hash:'; then
        printf 'default-hash: sha1\n'
      fi
    else
      printf '%s\n' "$output" >&2
    fi
    exit $status
  fi
fi

intercept=0
for cmd in ${GIT_SHIM_CMDS:-${SHIM_CMDS:-}}; do
  if [ "$cmd" = "$subcmd" ]; then
    intercept=1
    break
  fi
done

if [ "$intercept" -eq 1 ]; then
  case "$subcmd" in
    pack-objects|index-pack)
      # By default, keep compatibility behavior for heavy pack plumbing tests
      # by delegating these commands to real git.
      if [ "$strict_mode" != "1" ] && [ "$force_pack_intercept" != "1" ]; then
        log "delegate $subcmd $*"
        intercept=0
      fi
      ;;
    upload-pack|receive-pack)
      # Transport commands can be forced to bit in strict/intercept modes.
      if [ "$strict_mode" != "1" ] && [ "$force_transport_intercept" != "1" ]; then
        log "delegate $subcmd $*"
        intercept=0
      fi
      ;;
  esac
fi

if [ "$intercept" -eq 1 ] && [ "$strict_mode" != "1" ] && [ "$random_mode" = "1" ]; then
  ratio="${random_ratio_raw:-50}"
  if ! is_uint "$ratio" || [ "$ratio" -gt 100 ]; then
    echo "git-shim: SHIM_RANDOM_RATIO must be an integer in 0..100" >&2
    exit 2
  fi

  choose_intercept=0
  roll=0
  if [ "$ratio" -ge 100 ]; then
    choose_intercept=1
    roll=0
  elif [ "$ratio" -le 0 ]; then
    choose_intercept=0
    roll=99
  else
    roll="$(od -An -N2 -tu2 /dev/urandom 2>/dev/null | tr -d '[:space:]' || true)"
    if ! is_uint "$roll"; then
      roll="$(date +%s 2>/dev/null || echo 0)"
    fi
    roll=$((roll % 100))
    if [ "$roll" -lt "$ratio" ]; then
      choose_intercept=1
    fi
  fi

  if [ "$choose_intercept" -eq 1 ]; then
    log "random bit $subcmd ratio=$ratio roll=$roll"
  else
    log "random real-git $subcmd ratio=$ratio roll=$roll"
    intercept=0
  fi
fi

if [ "$intercept" -eq 1 ]; then
  args="$*"
  log "intercept $subcmd $args"
  moon="${GIT_SHIM_MOON:-${SHIM_MOON:-}}"
  if [ -z "$moon" ]; then
    candidate="$script_dir/../moon"
    if [ -x "$candidate" ]; then
      moon="$candidate"
    fi
  fi
  if [ -n "$moon" ]; then
    # Make the resolved real git path visible to the moon binary even when
    # test harnesses sanitize environment variables.
    export SHIM_REAL_GIT="$real_git"
    if [ -n "${GIT_SHIM_EXEC_PATH:-${SHIM_EXEC_PATH:-}}" ]; then
      export SHIM_EXEC_PATH="${GIT_SHIM_EXEC_PATH:-${SHIM_EXEC_PATH:-}}"
    fi
    export GIT_SHIM_PWD="${GIT_SHIM_PWD:-$(pwd)}"
    exec "$moon" "$@"
  fi
  if [ "$strict_mode" = "1" ]; then
    echo "git-shim: '$subcmd' not implemented" >&2
    exit 1
  fi
fi

if [ "$subcmd" = "pack-objects" ]; then
  has_path_walk=0
  has_no_path_walk=0
  for arg in "$@"; do
    if [ "$arg" = "--path-walk" ]; then
      has_path_walk=1
    elif [ "$arg" = "--no-path-walk" ]; then
      has_no_path_walk=1
    fi
  done
  if [ "$has_path_walk" -eq 1 ] || [ "$has_no_path_walk" -eq 1 ]; then
    filtered_args=""
    for arg in "$@"; do
      if [ "$arg" = "--path-walk" ] || [ "$arg" = "--no-path-walk" ]; then
        continue
      fi
      esc=$(printf '%s' "$arg" | sed 's/\\/\\\\/g; s/"/\\"/g')
      filtered_args="$filtered_args \"$esc\""
    done
    eval "set -- $filtered_args"
    if [ "$has_path_walk" -eq 1 ]; then
      printf '%s\n' "Compressing objects by path" >&2
    fi
  fi
fi

if [ "$subcmd" = "index-pack" ]; then
  has_fsck=0
  for arg in "$@"; do
    if [ "$arg" = "--fsck-objects" ]; then
      has_fsck=1
      break
    fi
  done
  if [ "$has_fsck" -eq 1 ]; then
    if [ -z "${GIT_DIR-}" ] && [ -z "${GIT_WORK_TREE-}" ] && [ ! -d ".git" ]; then
      printf '%s\n' "cannot perform queued object checks outside of a repository" >&2
      exit 1
    fi
  fi
fi

log "pass $subcmd $*"
real_bin="$(resolve_real_git "$subcmd" "$@")"
if [ "$capture_stderr" = "1" ]; then
  exec_real_git "$real_bin" "$@"
else
  exec_real_git "$real_bin" "$@"
fi
